(libload "turtlebot/turtlebot")
(libload "libc/constants")

#? (cpp-dummy)
;; Load cpp includes.
(de cpp-dummy ()
  (cpheader "#include \"turtlebot/turtlebot.h\"")
  ())

#? turtlebot-c2v
;; Transformation from Kinect to Turtlebot base.
(defparameter turtlebot-c2v [f [0 0 1 -0.10] [1 0 0 -0.01] [0 1 0 -0.25]])

#? feature-map
;; A generic structure used to store feature vectors. Has center and
;; scale parameters best for rectangular maps.
(defclass feature-map object
  ((-idx3- (-float-)) data)
  ((-idx1- (-float-)) scale)
  ((-idx1- (-int-)) center)
  ((-idx1- (-int-)) full-dim)
  ((-idx1- (-int-)) half-dim)
  ((-float-) pcl-density)
  ((-int-) features)
  )

#? (new feature-map <half-dim> <scale> <features>)
;; Create a feature map with the given dimensions and scale. For each of the
;; cells there is a single feature vector with <features> entries. This data
;; has no implicit semantics.
(defmethod feature-map feature-map (half-dim- scale- features-)
  ((-idx1- (-int-)) half-dim-)
  ((-idx1- (-float-)) scale-)
  ((-int-) features-)
  (setq half-dim (idx-copy half-dim-))
  (setq scale (idx-copy scale-))
  (setq features features-)
  (setq center (idx-mul half-dim [i 2 1]))
  (setq full-dim (idx-add (idx-mul half-dim [i 2 2]) [i 1 1]))
  (setq data (float-matrix (full-dim 0) (full-dim 1) features))
  (setq pcl-density 0)
  )

#? (==> <feature-map> world2map-cell <world-coord> <cell>)
;; Compute the map cell for the given world coordinate. The origin is always
;; the map center.
(defmethod feature-map world2map-cell (world-coord cell)
  ((-idx1- (-float-)) world-coord)
  ((-idx1- (-int-)) cell)
  (let ((x-offset (/ (world-coord 1) (scale 0)))
        (y-offset (/ (world-coord 0) (scale 1))))
    (idx-copy center cell)
    (cell 0 (+ (cell 0) (* y-offset -1)))
    (cell 1 (+ (cell 1) x-offset))
    )
  cell
  )

#? (==> <feature-map> in-bounds <cell>)
;; Test if cell is within the map area.
(defmethod feature-map in-bounds (cell)
  ((-idx1- (-int-)) cell)
  (and (and (>= (cell 0) 0) (>= (cell 1) 0))
       (and (< (cell 0) (full-dim 0)) (< (cell 1) (full-dim 1))))
  )

#? cost-map
;; A single float per cell of a related feature-map.
(defclass cost-map feature-map
  ((-int-) inf-cost)
  )

#? (new cost-map <fm>)
;; Construct a cost-map from an existing feature-map <fm>.
(defmethod cost-map cost-map (fm)
  ((-obj- (feature-map)) fm)
  (setq inf-cost 9999)
  (==> this feature-map :fm:half-dim :fm:scale 1)
  (setq pcl-density :fm:pcl-density)
  )

#? (vec3tformcoord <v> <mat> <res>)
;; Transform 3d vector <v> by the matrix <mat>. This function will ignore
;; any transformations in homogenous coordinate w.
(de vec3tformcoord (v mat res)
  ((-idx1- (-float-)) v)
  ((-idx2- (-float-)) mat)
  ((-idx1- (-float-)) res)
  (let ((rows (idx-dim mat 0)))
    (idx-changedim mat 0 3)
    (idx-m0clear res)
    (idx-pbloop ((mat-r mat)(res-c res))
      ;; Apply rotation and scale.
      (idx-changedim mat-r 0 3)
      (idx-bloop ((mat-rc mat-r)(v-c v))
        (res-c (+ (res-c) (* (mat-rc) (v-c))))
        )
      (idx-changedim mat-r 0 4)
      ;; Apply translation.
      (res-c (+ (res-c) (mat-r 3)))
      )
    (idx-changedim mat 0 rows)
    )
  res
  )

#?  (xyz2feature-map <xyz> <transform> <fm>)
;; Fill in feature map for each map cell using the point cloud <xyz>
;;   Features:
;;   [0] - Number of points.
;;   [1] - Sum of heights.
;;   [2] - Sum of squared heights.
(de xyz2feature-map (xyz transform fm)
  ((-idx2- (-float-)) xyz)
  ((-idx2- (-float-)) transform)
  ((-obj- (feature-map)) fm)
  (let ((map-cell [i 0 0])               ;; Target cell for xyz point.
        (xyz-tform (float-matrix-nc 3))) ;; Transformed xyz point.
    (idx-clear :fm:data)
    ;; Compute density.
    (setq :fm:pcl-density (/ (idx-dim xyz 0) (* 640 480)))
    ;;(printf ":fm:pcl-density %f\n" :fm:pcl-density)
    ;; For all point cloud points.
    (idx-bloop ((xyz xyz))
      ;; Transform to robot world.
      (vec3tformcoord xyz transform xyz-tform)
      ;; Find target cell.
      (==> fm world2map-cell xyz-tform map-cell)
      ;; Check cell in bounds.
      (if (==> fm in-bounds map-cell)
        (let ((h (* -1 (xyz-tform 2))))
          ;; Increment count.
          (:fm:data (map-cell 0) (map-cell 1) 0
            (+ (:fm:data (map-cell 0) (map-cell 1) 0) 1))
          ;; Sum height.
          (:fm:data (map-cell 0) (map-cell 1) 1
            (+ (:fm:data (map-cell 0) (map-cell 1) 1) h))
          ;; Sum square height.
          (:fm:data (map-cell 0) (map-cell 1) 2
            (+ (:fm:data (map-cell 0) (map-cell 1) 2) (* h h)))
          )
        ()
        )
      )
    )
  fm
  )

#? (feature-map2cost-map <fm> <cm>)
;; Compute the cost map for the given feature map.
(de feature-map2cost-map (fm cm)
  ((-obj- (feature-map)) fm)
  ((-obj- (cost-map)) cm)
  (setq :cm:pcl-density :fm:pcl-density)
  (idx-bloop ((cell-r :fm:data) (cost-r :cm:data))
    (idx-bloop ((cell cell-r) (cost cost-r))
      (let ((num (cell 0))
            (sum_x (cell 1))
            (sum_xx (cell 2)))
        ;; Store infinite cost for no points.
        (if (= 0 num)
          (cost 0 :cm:inf-cost)

          ;; Else store average height plus variance.
          ;; Var = ((Sum(X_i^2) - (2 * Mu * Sum(X_i))) / N) + Mu^2
          (let* ((mu (/ sum_x num))
                 (var (+ (/ (- sum_xx (* 2 (* mu sum_x))) num) (* mu mu))))
              (cost 0 (+ (abs mu) var))
            )
          )
        )
      )
    )
  cm
  )

(defclass turtlebot-driver-0 object
  ((-obj- (turtlebot)) tb)
  ((-float-) vlin-max) ;; Max linear velocity.
  ((-float-) vang-max) ;; Max angular velocity.
  ((-float-) vlin-cur) ;; Current linear velocity (robot X-axis).
  ((-float-) vang-cur) ;; Current angular velocity (robot Z-axis).
  ((-idx1- (-float-)) near-check-dim) ;; Dimensions of near collision box.
  ((-float-) tb-height)               ;; Safe clearance for height.
  ((-float-) tb-drive-height)         ;; Safe driving height.
  ((-int-) drive-state)
  )

;; Notes:
;;  - Another way to detect that the robot is near collision with an object is
;;    to test the proportion of points that are NaN in the dense point cloud.
;;    When the camera is <1m from an occluding surface, the points will all be
;;    NaN since surfaces <1m produce no measurements. A highly occluded depth
;;    image is a strong signal that the robot should stop moving.

(defconstant "DRIVE_STATE_NORMAL" 0)
(defconstant "DRIVE_STATE_SCAN" 1)
(defconstant "DRIVE_STATE_PANIC" 2)
(defconstant "DRIVE_CMD_RIGHT" 1)
(defconstant "DRIVE_CMD_LEFT" -1)
(defconstant "DRIVE_CMD_STRAIGHT" 0)

#? (new turtlebot-driver-0 <tb> <vlin-max> <vang-max>
;; Initialize a turtlebot driver with linear and angular speed limits.
;;(defmethod turtlebot-driver-0 turtlebot-driver-0 (tb- vlin-max- vang-max-)
(defmethod turtlebot-driver-0 turtlebot-driver-0 (tb- vlin-max- vang-max-)
  ((-obj- (turtlebot)) tb-)
  ((-float-) vlin-max-)
  ((-float-) vang-max-)
  (setq tb tb-)
  (setq vlin-max vlin-max-)
  (setq vang-max vang-max-)
  (setq vlin-cur 0)
  (setq vang-cur vang-max)
  (setq near-check-dim [f 0.55 0.55])
  (setq tb-height 0.5)
  (setq tb-drive-height 0.05)
  ;; Init driving modes. Start by scanning.
  (setq drive-state @DRIVE_STATE_SCAN)
  )

#? (==> <turtlebot-driver-0> check-near-obstacles <cm> <cm-rgb>)
;; Check in the near-collision box for obstacles and emit a code indicating
;; whether or not obstacles are detected. The code indicates the direction
;; that the robot should pivot in order to avoid the obstacle.
(defmethod turtlebot-driver-0 check-near-obstacles (cm cm-rgb)
  ((-obj- (cost-map)) cm)
  ((-idx3- (-int-)) cm-rgb)
  ;; Check the immediate vicinity of the robot for obstacles.
  ;; If there are obstacles, then we will enter drive-state-scan.
  (let* ((near-collision ())
         (near-check-half-dim-cells (idx-div (idx-div near-check-dim [f 2 2]) :cm:scale))
         (c-idx-begin (- (:cm:center 1) (near-check-half-dim-cells 0)))
         (c-idx-end (+ (:cm:center 1) (near-check-half-dim-cells 0)))
         (c-idx c-idx-begin)
         (row-torques (float-matrix-nc (- c-idx-end c-idx-begin)))
         (r-idx-begin (:cm:center 0))
         (r-idx-end (- (- (:cm:center 0) (* 2 (near-check-half-dim-cells 1))) 1))
         (near-torques (float-matrix (- r-idx-begin r-idx-end)))
         (r-idx r-idx-begin))
    (idx-bloop ((torque near-torques))
      (idx-clear row-torques)
      (setq c-idx c-idx-begin)
      ;; Compute torque for the image row.
      (idx-bloop ((px-torque row-torques))
        (let ((lever-len (- c-idx (:cm:center 1)))
              (cost (:cm:data r-idx c-idx 0)))
          (if (= :cm:inf-cost cost)
            ;; No torque for no points.
            (progn
              ;; Paint this square light blue.
              (cm-rgb r-idx c-idx 0 128)
              (cm-rgb r-idx c-idx 1 128)
              (cm-rgb r-idx c-idx 2 255)
              (px-torque 0) ;; No torque!
              )

            ;; Check for a collision using tb-height and tb-drive-height.
            (if (and (< tb-height cost) (< tb-drive-height cost))
              (px-torque 0)

              ;; Red visual (for a hit).
              (setq near-collision t)
              (let ((color (min 255 (max 0 (* (/ cost (* 2 tb-height)) 255)))))
                (cm-rgb r-idx c-idx 0 color)
                (cm-rgb r-idx c-idx 1 0)
                (cm-rgb r-idx c-idx 2 0)
                )
              ;; Compute torque at this index.
              (px-torque (* lever-len cost))
              )
            )
          )
        (incr c-idx)
        )
      ;; Increment next row and return sum of torques.
      (setq r-idx (- r-idx 1))
      (torque ((idx-sum row-torques)))
      )
    (printf ":cm:pcl-density %f\n" :cm:pcl-density)
    (if (or near-collision (< :cm:pcl-density 0.4))
      ;; Go  right for negative torque, left otherwise.
      (if (< ((idx-sum near-torques)) 0) @DRIVE_CMD_RIGHT @DRIVE_CMD_LEFT)
      ;; No near collision ==> zero.
      @DRIVE_CMD_STRAIGHT
      )
    )
  )

#? (==> <turtlebot-driver-0> drive <cm> <cm-rgb>)
;; Drive the robot based on the given cost-map <cm>. The RGB image <cm-rgb> is
;; used for debug output.
(defmethod turtlebot-driver-0 drive (cm cm-rgb)
  ((-obj- (cost-map)) cm)
  ((-idx3- (-int-)) cm-rgb)
  ;; We always check the near obstacle code no matter what since obstcles near
  ;; to the robot are a consistent threat.
  (let ((near-obstacle-code (==> this check-near-obstacles cm cm-rgb))
        (state-before drive-state))
    (cond 
      ((= @DRIVE_STATE_NORMAL drive-state)
        ;; TODO(reissb) -- 20120311 -- Use map data from the distance to predict
        ;;   collisions and avoid them.

        ;; Drive straigt unless there are obstacles nearby.
        (if (= @DRIVE_CMD_STRAIGHT near-obstacle-code)
          ;; Go forward.
          (progn (setq vlin-cur vlin-max) (setq vang-cur 0))

          ;; Else scan using obstacle direction.
          (printf "CH_CMD - DRIVE_STATE_SCAN : ")
          (setq vlin-cur 0)
          (setq vang-cur (if (= @DRIVE_CMD_RIGHT near-obstacle-code)
                           (progn (printf "SCAN-RIGHT\n") (* -1 vang-max))
                           (printf "SCAN-LEFT\n") vang-max))
          (setq drive-state @DRIVE_STATE_SCAN)
          )
        ()
        )
      ((= @DRIVE_STATE_SCAN drive-state)
        ;; TODO(reissb) -- 20120311 -- Detect if we are stuck in scan mode
        ;;   and enter panic mode instead?

        ;; Return to normal state if there are no obstacles. Otherwise
        ;; continue scanning in the current direction.
        (if (= @DRIVE_CMD_STRAIGHT near-obstacle-code)
          (progn (printf "CH_CMD - DRIVE_STATE_NORMAL\n")
                 (setq drive-state @DRIVE_STATE_NORMAL))
          )
        ()
        )
      ((= @DRIVE_STATE_PANIC drive-state)
        ;; Do nothing. Stillness is panic signal.
        (setq vlin-cur 0)
        (setq vang-cur 0)
        ()
        )
      )
    ;; Only move when not changing states.
    (if (= state-before drive-state)
      (let ((linear [d 0 0 0])(angular [d 0 0 0]))
        (linear 0 vlin-cur)
        (angular 2 vang-cur)
        (printf "publish-cmd-vel [%f 0 0] [0 0 %f]\n" vlin-cur vang-cur)
        (==> tb publish-cmd-vel linear angular)
        )
      )
    )
  ()
  )

(de test-turtlebot-driver-0 (tb n)
  ;; A valid turtlebot is required.
  (if (not tb)
    (printf "Error : turtlebot is NULL\n")

    ;; Initialize streams (no harm to repeat this).
    (==> tb start-sub-camera-depth-points)
    (==> tb start-pub-cmd-vel)
    ;; Create feature, cost, and cost rgb maps.
    (let* ((fm (new feature-map [i 100 100] [f 0.02 0.02] 3))
           (cm (new cost-map fm))
           (cm-rgb (int-matrix (:cm:full-dim 0) (:cm:full-dim 1) 3))
           (driver (new turtlebot-driver-0 tb 0.4 0.4)))
      ;; Create properly sized window if it doesn't exist.
      (if (not window) (
        let ((wnd-width 0)(wnd-height 0))
          (setq wnd-width (* 2 (idx-dim cm-rgb 1)))
          (setq wnd-height (* 2 (idx-dim cm-rgb 0)))
          (new-window 0 0 wnd-width wnd-height)
          )
        )
      ;; Do n loops of cost map.
      (for (i 0 n)
        (process-depth-points tb turtlebot-c2v fm cm)
        (cost-map2rgb 0.5 cm cm-rgb)
        (==> driver drive cm cm-rgb)
        ;; Draw maps.
        (rgb-draw-matrix 0 0 cm-rgb 2 2)
        )
      :driver:drive-state
      )
    )
  ()
  )

#? (process-depth-points <tb> <transform> <fm> <cm>)
;; Get a point cloud and convert it to a cost map.
(de process-depth-points (tb transform fm cm)
  ((-obj- (turtlebot)) tb)
  ((-idx2- (-float-)) transform)
  ((-obj- (feature-map)) fm)
  ((-obj- (cost-map)) cm)
  ;; Grab new depth data.
  (while (< (==> tb update-camera-depth-points) 0) ())
  ;; Convert points to feature map.
  (xyz2feature-map :tb:camera-depth-points transform fm)
  (feature-map2cost-map fm cm)
  cm
  )

#? (cost-map2rgb <max-cost> <cm> <cm-rgb>)
;; Convert the cost map into a display image.
(de cost-map2rgb (max-cost cm cm-rgb)
  ((-float-) max-cost)
  ((-obj- (cost-map)) cm)
  ((-idx3- (-int-)) cm-rgb)
  (idx-bloop ((cost-r :cm:data) (cost-rgb-r cm-rgb))
    (idx-bloop ((cost cost-r) (cost-rgb cost-rgb-r))
      (if (not (= :cm:inf-cost (cost 0)))
        ;; Shade of gray based on cost in range [0, max-cost].
        (let* ((color (min 255 (max 0 (* (/ (cost 0) max-cost) 255)))))
          (idx-bloop ((rgb cost-rgb)) (rgb color))
          )
        ;; Else blue.
        (idx-copy [i 0 0 255] cost-rgb)
        )
      )
    )
  cm-rgb
  )

(dhc-make-with-c++ () ()
  cpp-dummy
  (feature-map
    feature-map
    world2map-cell
    in-bounds
    )
  (cost-map
    cost-map
    )
  vec3tformcoord
  xyz2feature-map
  feature-map2cost-map
  (turtlebot-driver-0
    turtlebot-driver-0
    check-near-obstacles
    drive
    )
  process-depth-points
  cost-map2rgb
  )

